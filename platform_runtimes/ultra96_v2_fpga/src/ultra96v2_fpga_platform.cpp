/* Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/* Generated by Halide Compiler */
#include "rdai_clockwork_platform.h"

/* Other includes */
#include "rdai_api.h"
#include "rdai-cma.h"

#include <future>
#include <vector>
#include <string.h>
#include <sstream>

using namespace std;

static uint32_t hardware_id = 1;
static RDAI_ID urdai_id = {hardware_id};
static RDAI_VLNV urdai_vlnv;

static vector<future<RDAI_Status> > asyncStatuses;
static uint32_t async_id = 1;

static map<string, string> = {
        {"bitstream", "example.bit.bin"},
        {"dtbo", "pl.dtbo"}
};

typedef struct UserData
{
    uint32_t dev_id;
    uint32_t dev_status;
    char dev_vlnv[128];
    uint64_t timeout;
    RDAIDrvMemObj in_obj;
    RDAIDrvMemObj out_obj;

} UserData;    

// =================== HELPER FUNCTIONS =================================

/**
 * Construct an error status
 *
 * @param reason The reason for the error
 * @return The constructed error status
 */
static RDAI_Status make_status_error( RDAI_ErrorReason reason = RDAI_REASON_UNIMPLEMENTED )
{
    RDAI_Status status;
    status.status_code = RDAI_STATUS_ERROR;
    status.error_reason = reason;
    return status;
}

 /**
  * Construct an async status
  *
  * @return The constructed async status
  */
static RDAI_Status make_status_ok_async(void *udata)
{
	RDAI_Status status;
	status.status_code = RDAI_STATUS_OK;
	status.async_handle.id.value = async_id;
	status.async_handle.user_data = udata;
	async_id++;	
    return status;
}

 /**
  * Construct a success status
  *
  * @return The constructed success status
  */
static RDAI_Status make_status_ok()
{
    RDAI_Status status;
    status.status_code = RDAI_STATUS_OK;
    return status;
}

// =================== Platform Ops Implementation ==============================
//
// See RDAI API documentation for the functionality of these APIs
//

static RDAI_MemObject *op_mem_allocate( RDAI_MemObjectType mem_object_type, 
										size_t size, 
										RDAI_Device *device )
{
	RDAI_MemObject *return_obj = (RDAI_MemObject *) malloc(sizeof(RDAI_MemObject));
	return_obj->user_tag = malloc(sizeof(RDAIDrvMemObj));

	RDAIDrvMemObj *drv_mem_obj = (RDAIDrvMemObj *) return_obj->user_tag;
	drv_mem_obj->size = size;

    // open RDAI DMA Driver
    fd_dma = open("/dev/rdai_dma", O_RDWR);
    if(fd_dma < 0) {
        printf("failed to open RDAI DMA driver\n");
	return -1;
    }
    printf("successfully opened RDAI DMA driver\n");

    // allocate buffer
	printf("allocating buffer\n");
    if(rdai_cma_alloc(fd_dma, drv_mem_obj) == 0) {
        // debug
	    // printf("\tphys_addr = %lx\n", drv_mem_obj->phys_addr);
	    // printf("\tkern_addr = %lx\n",  drv_mem_obj->kern_addr);
	    // printf("\tsize = %lx\n", drv_mem_obj->size);
	    // printf("\talloc_size = %lx\n", drv_mem_obj->alloc_size);
    	// mmap buffers
        printf("mmapping buffer\n");
        void *uaddr = rdai_cma_mmap(fd_dma, drv_mem_obj);
        if(uaddr == MAP_FAILED) {
            printf("mapping buffer failed\n");
            printf("deallocating buffer\n");
            rdai_cma_free(fd_dma, &drv_mem_obj);
        } else {
            printf("mapped buffer @ %p\n", uaddr);
            return_obj->mem_type 	= mem_object_type;
            return_obj->device 		= device;
            return_obj->view_type 	= RDAI_VIEW_FULL;
            return_obj->parent 		= NULL;
			return_obj->host_ptr	= (uint8_t *) drv_mem_obj->user_addr;
			return_obj->device_ptr 	= (uint8_t *) drv_mem_obj->phys_addr;
            return_obj->size 		= size;
            printf("successfully allocated and mmapped buffer");
            return return_obj;
		}
    }
    printf("failed to allocate buffer\n");
    free(drv_mem_obj);
    free(return_obj);
    return NULL;
}

static RDAI_Status op_mem_free( RDAI_MemObject *mem_object )
{
    if (!mem_object) {
    	printf("mem_object pointer is NULL")
	    return make_status_error();
    }
    RDAIDrvMemObj *drv_mem_obj = (RDAIDrvMemObj *) mem_object->user_tag;
    printf("freeing buffers\n");
    if(rdai_cma_free(fd_dma, drv_mem_obj)) {
        printf("failed to free buffer\n");
    }
    free(drv_mem_obj);
    free(mem_object);
    printf("completed freeing buffer\n");
    return make_status_ok();
}

static RDAI_Status op_mem_copy( RDAI_MemObject *src, RDAI_MemObject *dest )
{
	size_t size = min(src->size, dest->size);

	memcpy(dest->host_ptr, src->host_ptr, size);
	dest->size 	= src->size;
	return make_status_ok();
}

static RDAI_Status op_mem_copy_async( RDAI_MemObject *src, RDAI_MemObject *dest )
{
	// asyncStatuses.push_back( async( op_mem_copy, src, dest ) );
	// return make_status_ok_async();
	return make_status_error();
}

static RDAI_MemObject* op_mem_crop( RDAI_MemObject *src, 
									size_t offset, 
									size_t cropped_size )
{
	RDAI_MemObject *croppedObject = (RDAI_MemObject *) malloc(sizeof(RDAI_MemObject));

	croppedObject->mem_type 	= src->mem_type;
	croppedObject->view_type 	= RDAI_VIEW_CROP;
	croppedObject->device 		= src->device;
	croppedObject->parent 		= src;
	croppedObject->host_ptr		= (src->host_ptr)+offset;
	croppedObject->device_ptr 	= (src->device_ptr == NULL)? NULL : (src->device_ptr)+offset;
	croppedObject->size 		= cropped_size;
	// croppedObject->flags 		= 0;
	croppedObject->user_tag 	= src->user_tag;

	return croppedObject;
}

static RDAI_Status op_mem_free_crop( RDAI_MemObject *cropped_mem_object )
{
	free(cropped_mem_object);
	return make_status_ok();
}

static RDAI_Platform* op_platform_create( void )
{
	return &rdai_clockwork_platform;
}

static RDAI_Status op_platform_destroy( RDAI_Platform *platform )
{
	return make_status_error();
}

static RDAI_Status op_platform_init( RDAI_Platform *platform, void *user_data )
{
	map<string,string> map& = *static_cast<std::map<string,string> *> (user_data);
	string bitstream = map["bitstream"];
	string dtbo = map["dtbo"];

	ostringstream oss;
	oss << "sudo ./fpgautil -b "<< bitstream << " -o " << dtbo;

	system(oss.str());
	return make_status_ok();
}

static RDAI_Status op_platform_deinit( RDAI_Platform *platform, void *user_data )
{
	map<string,string> map& = *static_cast<std::map<string,string> *> (user_data);
	string dtbo = map["dtbo"];

	ostringstream oss;
	oss << "sudo ./fpgautil -R -o " << dtbo;
	
	system(oss.str());
	return make_status_ok();
}

static RDAI_Status op_device_init( RDAI_Device *device, void *user_data )
{
	return make_status_error();
}

static RDAI_Status op_device_deinit( RDAI_Device *device, void *user_data )
{
	return make_status_error();
}

static RDAI_Status op_device_run( RDAI_Device *device, 
								  RDAI_MemObject **mem_object_list )
{
	RDAI_Status async_status = op_device_run_async(device, mem_object_list);
	RDAI_AsyncHandle* handle = &async_status.async_handle;
	op_sync(handle);
    return async_status;
}

static RDAI_Status op_device_run_async( RDAI_Device *device, 
										RDAI_MemObject **mem_object_list )
{
    UserData udata;
    udata.timeout = 3000;
    udata.dev_id = 0;
    udata.in_obj = *(mem_object_list[0]->user_tag);
    udata.out_obj = *(mem_object_list[1]->user_tag);
    strcpy(udata.dev_vlnv, device->vlnv);

    int status;
    printf("starting device run async\n");
    if(status = ioctl(fd_dma, DEVICE_RUN_ASYNC, &udata)) {
        printf("device run async failed!\n");
    }
    return (status == 0)? make_status_ok_async(&udata) : make_status_error();
}

static RDAI_Status op_sync( RDAI_AsyncHandle *async_handle )
{
	void *udata = async_handle->user_data;

	int status;
    printf("starting device sync\n");
    if(status = ioctl(fd_dma, DEVICE_SYNC, udata)) {
        printf("device sync failed with code [%d]!\n", status);
        return make_status_error();
    } else {
        printf("device sync ran\n");
    }

    return make_status_ok();

	// if(async_handle && async_handle->platform) {
 //        return asyncStatuses[async_handle->id.value - 1].get();
 //    }
 //    return make_status_error();
	
}

// ======================== PlatformOps ========================================
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

struct RDAI_PlatformOps ultra96v2_fpga_ops = {
    .mem_allocate       = op_mem_allocate,
    .mem_free           = op_mem_free,
    .mem_copy           = op_mem_copy,
    .mem_copy_async     = op_mem_copy_async,
    .mem_crop           = op_mem_crop,
    .mem_free_crop      = op_mem_free_crop,
    .platform_create    = op_platform_create,
    .platform_destroy   = op_platform_destroy,
    .platform_init      = op_platform_init,
    .platform_deinit    = op_platform_deinit,
    .device_init        = op_device_init,
    .device_deinit      = op_device_deinit,
    .device_run         = op_device_run,
    .device_run_async   = op_device_run_async,
    .sync               = op_sync
};

#ifdef __cplusplus
}
#endif